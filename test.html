<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{margin:0; padding:0;}
        html,body {width: 100%;height: 100%;overflow: hidden;}
        #startButton, #launchButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid white;
            cursor: pointer;
            z-index: 100;
            font-family: sans-serif;
            transition: background-color 0.3s;
        }
        #startButton:hover, #launchButton:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        #launchButton {
            top: 80%; /* Move to bottom area */
            display: none; /* Hidden initially */
        }
        #viewControls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: none; /* Hidden initially, shown in Scene 3 */
            z-index: 100;
        }
        .view-btn {
            padding: 10px 20px;
            margin-left: 10px;
            font-size: 16px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid white;
            cursor: pointer;
            font-family: sans-serif;
            transition: background-color 0.3s;
        }
        .view-btn:hover, .view-btn.active {
            background-color: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div id="startButton">Visit The Launch Site</div>
    <div id="launchButton">Launch!</div>
    <div id="viewControls">
        <button id="boosterViewBtn" class="view-btn">Booster View</button>
        <button id="shipViewBtn" class="view-btn active">Ship View</button>
    </div>
    
    <!-- Success Modal -->
    <div id="successModal" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 200;">
        <div style="background: rgba(0,0,0,0.8); padding: 40px; border: 2px solid white; color: white;">
            <h1 style="margin-bottom: 20px; font-family: sans-serif;">SUCCESS LANDING</h1>
            <button id="restartBtn" style="padding: 15px 30px; font-size: 20px; cursor: pointer; background: white; border: none; font-family: sans-serif;">Restart</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from "three";
        import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
        import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

        //create variables
        const interval = 15.0;
        var time = 0; // Start at 0
        var launchTime = 0; // Independent time for rocket launch
        var currentScene = 1; // 1: Launch, 2: Space, 3: Separation, 4: Landing
        var activeView = 'ship'; // 'ship' or 'booster'
        const degree = Math.PI / 180
        let isPlaying = false; // Animation state flag
        let isLaunchPhase = false; // Flag for launch phase


        // Helper to create a soft particle texture
        function getSoftParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = getSoftParticleTexture();

        // Create a scene
        const scene = new THREE.Scene();

        const vent = createParticleSystem(0xffffff, 0.03, 0.6, particleTexture, THREE.NormalBlending);
        const exhaust = createParticleSystem(0xffaa33, 0.015, 0.9, particleTexture, THREE.AdditiveBlending);
        const exhaust2 = createParticleSystem(0xffaa33, 0.015, 0.9, particleTexture, THREE.AdditiveBlending); // Added for Scene 4
        const fog = createParticleSystem(0xffffff, 0.2, 0.15, particleTexture, THREE.NormalBlending); // White, NormalBlending

        // Create a camera
        const camera = new THREE.PerspectiveCamera(105, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        camera.position.set(0, 0.2, 4.5); // Default fallback
        camera.rotation.set(-0.2, 0, 0);  // Default fallback

        // Create Booster Camera (for Scene 3)
        const boosterCamera = new THREE.PerspectiveCamera(105, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Position will be updated in animation loop relative to booster


        // Create Elements
        const light1 = new THREE.PointLight(0x404040, 0.5);
        light1.position.set(5, 5, 5);
        scene.add(light1);


        const light2 = new THREE.DirectionalLight(0xffffff, 2);
        light2.position.set(5, 1, 3);
        light2.castShadow = true;
        scene.add(light2);

        const light3 = new THREE.DirectionalLight(0xffffff, 4);
        light3.position.set(5, 1, 1);
        light3.castShadow = true;
        scene.add(light3);

        const light4 = new THREE.PointLight(0xFF9A0D, 0, 100); // Start with 0 intensity
        light4.position.set(0,0.5,0)
        scene.add(light4);

        // Shockwave Effect for Launch (Scheme C)
        const shockwaveGeometry = new THREE.SphereGeometry(1, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.5); // Hemisphere
        const shockwaveMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xaaaaaa, 
            transparent: true, 
            opacity: 0.0,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const shockwaveMesh = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
        shockwaveMesh.position.set(0, 0, 0); // Ground level
        shockwaveMesh.rotation.x = 0; // Face up (Default is top hemisphere)
        shockwaveMesh.visible = false;
        scene.add(shockwaveMesh);

        const textureLoader = new THREE.TextureLoader();
        const skyTexture = textureLoader.load('sky.jpeg');
        const skyMaterialOne = new THREE.MeshStandardMaterial({ //color: 0xff000, 
            map: skyTexture, side: THREE.BackSide, emissive: 0xA1E9F7, emissiveIntensity: 0.8});

        const skyGeometryOne = new THREE.SphereGeometry(20, 20, 20);
        const skyMeshOne = new THREE.Mesh(skyGeometryOne, skyMaterialOne);
        skyMeshOne.rotation.set(0, 0.5, 0.1);
        skyMeshOne.position.set(0, 0, 5);
        scene.add(skyMeshOne);


        const skyTextureTwo = textureLoader.load('sky2.jpeg');
        const skyMaterialTwo = new THREE.MeshStandardMaterial({ //color: 0xff000, 
            map: skyTextureTwo, side: THREE.BackSide, emissive: 0xA1E9F7, emissiveIntensity: 0.2});

        const skyGeometryTwo = new THREE.SphereGeometry(20, 20, 20);
        const skyMeshTwo = new THREE.Mesh(skyGeometryTwo, skyMaterialTwo);
        skyMeshTwo.rotation.set(0, 0, 0);
        skyMeshTwo.position.set(-1000, -1000, -1000);
        scene.add(skyMeshTwo);


        // Create a renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Load models
        const loader = new GLTFLoader();

        var stationaries = null;
        loader.load(
            'stationaries2.glb',
            (object) => {
                stationaries = object.scene
                scene.add(stationaries);
            },
        );

        var factory_door_l = null;
        loader.load(
            'factory_door3.glb',
            (object) => {
                factory_door_l = object.scene
                factory_door_l.position.set(-0.72, 0, 4);
                factory_door_l.scale.set(1.5, 1.5, 1.5);
                scene.add(factory_door_l);
            },
        );

        var factory_door_r = null;
        loader.load(
            'factory_door4.glb',
            (object) => {
                factory_door_r = object.scene;
                factory_door_r.position.set(0.72, 0, 4);
                factory_door_r.scale.set(1.5, 1.5, 1.5);
                scene.add(factory_door_r);
            },
        );

        var entire_starship = null;
        loader.load(
            'entire_starship.glb',
            (object) => {
                entire_starship = object.scene;
                scene.add(entire_starship);
            },
        );

        var seperated_starship = null;
        var seperated_tail = null;
        loader.load(
            'seperated_starship.glb',
            (object) => {
                seperated_starship = object.scene;
                seperated_tail = object.scene.getObjectByName('tail')
                seperated_starship.position.set(-1000, -1000, 0); // Start hidden
                seperated_starship.rotation.set(0 , 140 * degree, 80 * degree)
                scene.add(seperated_starship);
            },
        );

        // --- Additional Loaders from Original Scene (for Scenes 3 & 4) ---
        var stationaries_2 = null;
        loader.load(
            'stationaries3.glb',
            (object) => {
                stationaries_2 = object.scene
                stationaries_2.position.set(-1000, -1000, 0)
                scene.add(stationaries_2);
            },
        );

        var arm_1 = null;
        loader.load(
            'arm1.glb',
            (object) => {
                arm_1 = object.scene
                arm_1.position.set(-1000, -1000, 0)
                scene.add(arm_1);
            },
        );

        var arm_2 = null;
        loader.load(
            'arm2.glb',
            (object) => {
                arm_2 = object.scene
                arm_2.position.set(-1000, -1000, 0)
                scene.add(arm_2);
            },
        );
        
        var seperated_head = null;
        loader.load(
            'head.glb',
            (object) => {
                seperated_head = object.scene;
                seperated_head.position.set(-1000, -1000, 0);
                scene.add(seperated_head);
            },
        );

        var seperated_booster = null;
        loader.load(
            'booster.glb',
            (object) => {
                seperated_booster = object.scene;
                seperated_booster.position.set(-1000, -1000, 0);
                scene.add(seperated_booster);
            },
        );


        // define animation control functions
        function cameraAnimationSceneOne(time) {
            camera.position.z = 4.5 - Math.log10(time + 1) * 0.8;
            camera.setFocalLength(Math.max(15 - (time / 5) * 3, 12));
            camera.rotation.x = Math.min(-0.28 + Math.log10(2 * (time / 5 * 10 + 0.5)) * 0.34, 0.18);
            camera.position.y = 0.2;
            camera.position.x = 0;
            cameraShake(time);
        }

        function doorAnimation(time){
            // Rotate 270 degrees (1.5 * PI) to completely hide the doors
            const maxRotation = 270 * Math.PI / 180; 
            // Slower open speed to match the larger angle over the 10s prep time
            const currentRot = Math.min(time * 0.5, maxRotation);
            
            if (factory_door_l && factory_door_r) {
                factory_door_l.rotation.y = currentRot;
                factory_door_r.rotation.y = -currentRot;
            }
        }
        

        function animate() {
            requestAnimationFrame(animate);
            if (isPlaying) {
                objectAnimations();
            }
            
            // Render using the active camera based on view selection
            // Only apply view switching in Scene 3
            if (currentScene === 3 && activeView === 'booster') {
                renderer.render(scene, boosterCamera);
            } else {
                renderer.render(scene, camera);
            }
        }

        // Start Button Logic
        const restartBtn = document.getElementById('restartBtn');
        const successModal = document.getElementById('successModal');
        const startButton = document.getElementById('startButton');
        const launchButton = document.getElementById('launchButton');
        const viewControls = document.getElementById('viewControls');
        const boosterViewBtn = document.getElementById('boosterViewBtn');
        const shipViewBtn = document.getElementById('shipViewBtn');

        startButton.addEventListener('click', () => {
            isPlaying = true;
            startButton.style.display = 'none';
        });

        launchButton.addEventListener('click', () => {
            isLaunchPhase = true;
            launchButton.style.display = 'none';
        });
        
        restartBtn.addEventListener('click', () => {
            window.location.reload();
        });

        boosterViewBtn.addEventListener('click', () => {
            activeView = 'booster';
            boosterViewBtn.classList.add('active');
            shipViewBtn.classList.remove('active');
        });

        shipViewBtn.addEventListener('click', () => {
            activeView = 'ship';
            shipViewBtn.classList.add('active');
            boosterViewBtn.classList.remove('active');
        });

        // Initialize camera and objects to animation start state
        function updateSceneState(currentTime) {
             camera.position.z = 4.5;
             camera.setFocalLength(15);
             camera.rotation.x = -0.28;
             camera.position.y = 0.2;
             camera.position.x = 0;
        }
        
        // Initialize scene state
        updateSceneState(time); 
        
        // Update the time variable to 0 so we start clean
        time = 0; 

        animate();

        function objectAnimations(){
            // --- Phase 1: Pre-Launch Preparation ---
            // Camera moves in, doors open. Global 'time' advances from 0 to 10.
            if (isPlaying && !isLaunchPhase) {
                if (time < 10.0) {
                    time += 0.01; // Advance preparation time
                } else {
                    // Preparation complete. Stop time and show Launch button.
                    launchButton.style.display = 'block'; 
                }
            } 
            // --- Phase 2: Launch Sequence ---
            // User clicked Launch. Independent 'launchTime' starts counting.
            else if (isLaunchPhase) {
                launchTime += 0.01;
                time += 0.01; // Keep global time moving (for potential background effects)
            }

            // --- System Updates ---
            fog.update(0.01)      // Always update fog (atmospheric)
            vent.update(0.02)     // Update vent physics (water/steam)
            exhaust.update(0.01)  // Update exhaust physics (fire)
            exhaust2.update(0.01) // Update scene 4 exhaust
            
            if(currentScene == 1){ // --- Scene 1 Logic ---
                // Hide the separated ship model (used in Scene 2) to prevent visual glitches
                if(seperated_starship) seperated_starship.position.set(-10000, -10000, -10000);

                // Apply animations based on respective timelines
                doorAnimation(time);       // Doors depend on prep time
                particleSystem(launchTime);// Particles depend on launch sequence
                
                if(isLaunchPhase) {
                    takeOff(launchTime);   // Rocket movement depends on launch sequence
                    cameraShake(launchTime); // Apply shake based on launch time
                    
                    // Shockwave Animation (Scheme C)
                    // Trigger at t=5 (Ignition)
                    const shockTime = launchTime - 5.0;
                    if (shockTime > 0 && shockTime < 2.0) {
                        shockwaveMesh.visible = true;
                        const scaleVal = 1 + shockTime * 20; // Rapid expansion
                        shockwaveMesh.scale.set(scaleVal, scaleVal * 0.5, scaleVal); // Taller dome
                        shockwaveMesh.material.opacity = 0.8 * (1 - (shockTime / 2.0)); // Higher initial opacity
                    } else if (shockTime >= 2.0) {
                        shockwaveMesh.visible = false;
                    }
                    
                    // --- Smooth Camera Tracking ---
                    // 1. Position: Freeze camera at the "ready" position (approx where time=10 left it)
                    // We simply DO NOT call cameraAnimationSceneOne(time) anymore.
                    // The camera stays exactly where it was when the button was clicked.
                    
                    // 2. Rotation: Smoothly track the rocket
                    // Create a dummy target matrix to calculate "LookAt" rotation
                    const dummyCam = camera.clone();
                    
                    // Calculate target point (Rocket center/top)
                    const targetPos = entire_starship.position.clone();
                    targetPos.y += 2.0; // Look slightly up at the body
                    
                    dummyCam.lookAt(targetPos); // Calculate desired orientation
                    
                    // Smoothly blend current camera quaternion to target quaternion
                    // Reduced factor from 0.05 to 0.01 for very slow, cinematic tracking
                    camera.quaternion.slerp(dummyCam.quaternion, 0.01);
                } else {
                    cameraAnimationSceneOne(time); // Standard prep animation
                }
            }
            
            // --- Scene Switch Logic ---

            // Transition Scene 1 -> Scene 2 (Space View)
            // Trigger at launchTime 30s
            if(launchTime >= 30 && currentScene == 1){ 
                hideSceneOne()
                
                // Kill all fog/particle effects instantly
                if(fog.mesh) scene.remove(fog.mesh);
                if(vent.mesh) scene.remove(vent.mesh);
                if(exhaust.mesh) scene.remove(exhaust.mesh);
                
                currentScene = 2;
                loadSceneTwo();
            }

            // Run Scene 2 Animation
            if(currentScene == 2) {
                // Map launchTime (starts at 30 for this scene) to original time (starts at 12)
                // Extended duration: 2.5s -> 4s (Shortened from 5s)
                // Slow down time by factor of 0.5: t_orig = 12 + (launchTime - 30) * 0.5
                const originalTime = 12 + (launchTime - 30) * 0.5;
                animationSceneTwo(originalTime);

                // Transition Scene 2 -> Scene 3 (Separation)
                // New duration 4s. So end time is 30 + 4 = 34
                if (launchTime >= 34.0) { 
                    hideSceneTwo();
                    currentScene = 3;
                    loadSceneThree();
                }
            }

            // Run Scene 3 Animation
            if(currentScene == 3) {
                // Map launchTime (starts at 34.0) to original time (starts at 14.5)
                // Scene 3 duration unchanged (10.5s), so map directly
                const originalTime = 14.5 + (launchTime - 34.0);
                animationSceneThree(originalTime);

                // Transition Scene 3 -> Scene 4 (Landing)
                // Duration 10.5s. End time = 34.0 + 10.5 = 44.5
                if (launchTime >= 44.5) { 
                    hideSceneThree();
                    currentScene = 4;
                    loadSceneFour();
                }
            }

            // Run Scene 4 Animation
            if(currentScene == 4) {
                // Map launchTime (starts at 44.5) to original time (starts at 25)
                const originalTime = 25 + (launchTime - 44.5);
                animationSceneFour(originalTime);
            }
        }

        function particleSystem(t){
            // t is launchTime now.
            // 0-5s: Water Deluge
            // 5s+: Ignition
            
            const flightTime = t - 5; // Time since ignition

            const pos = new THREE.Vector3(0, 0.6 + 0.03 * Math.pow(Math.max(0, flightTime), 3) * 0.2, -1); // Adjusted for slower ascent
            if (flightTime > 4) {
                 pos.x = 0.02 * Math.pow(flightTime-4, 3);
            }
            
            // Launch effects (Vent/Exhaust) ONLY during launch phase
            if (isLaunchPhase) {
                // Water Deluge / Pre-launch Phase (0s to 5s)
                // User identified 'vent' as the water effect
                if (t > 0 && t < 5) {
                     if(Math.random()<0.8) {
                        // Original vent parameters requested by user
                        vent.emit(new THREE.Vector3(0, 0.6, -1), new THREE.Vector3(0,-0.2,0), 3, 30);
                     }
                }

                // Ignition Sequence (Starts at t=5)
                if (flightTime > 0) {
                    // Continued venting during early flight (0s to 10s of flight)
                    // Extended from < 5 to < 10 as requested
                    if(flightTime < 10 && Math.random()<0.8) vent.emit(new THREE.Vector3(0, 0.6, -1), new THREE.Vector3(0,-0.2,0), 3, 30);
                    
                    // Exhaust (Fire) must follow the rocket!
                    const currentRocketY = 0.0012 * Math.pow(flightTime, 3); // Updated physics
                    const exhaustPos = new THREE.Vector3(0, currentRocketY + 0.6, -1); // Follow rocket Y
                    
                    // Horizontal shift adjustment if needed (later in flight)
                    if (flightTime > 15) {
                         exhaustPos.x = 0.002 * Math.pow(flightTime-15, 3);
                    }

                    // Exhaust (Fire)
                    // Reverted life to 0.8
                    // Ensure continuous emission
                    // Adjusted spread: Reduced to 70% of previous (0.3 * 0.7 = 0.21)
                    const jitter = new THREE.Vector3((Math.random()-0.5)*0.21, 0, (Math.random()-0.5)*0.21); 
                    if(flightTime > 0.5 && Math.random()<0.6) {
                        exhaust.emit(exhaustPos.clone().add(jitter), new THREE.Vector3(0,-2,0), 0.8, 50);
                    }
                }
            }

            // Fog around tanks - Always active for atmosphere
             // Tank 1 at approx [-1.9, 0, 0.9] - Emit from random height along the tank
             if(Math.random() < 0.6) { // Increased density probability
                const randomHeight = Math.random() * 1.0; // Reduced height (0.4x of 2.5)
                const spreadDir = new THREE.Vector3((Math.random()-0.5), -0.02, (Math.random()-0.5)).normalize().multiplyScalar(0.05);
                fog.emit(new THREE.Vector3(-1.9, randomHeight, 0.9), spreadDir, 5, 8); // Increased count per emit
             }
             // Tank 2 at approx [2.8, 0, -0.98] - Emit from random height along the tank
             if(Math.random() < 0.6) { // Increased density probability
                const randomHeight = Math.random() * 1.0; // Reduced height (0.4x of 2.5)
                const spreadDir = new THREE.Vector3((Math.random()-0.5), -0.02, (Math.random()-0.5)).normalize().multiplyScalar(0.05);
                fog.emit(new THREE.Vector3(2.8, randomHeight, -0.98), spreadDir, 5, 8); // Increased count per emit
             }
        }

        function cameraShake(time){
            // Shake ONLY during launch phase
            if(!isLaunchPhase) return;
            
            // Shake starts at ignition (t=5) and fades out over time
            // launchTime is passed as 'time' here
            
            const flightTime = time - 5.0;
            
            if(flightTime > 0 && flightTime < 20){ // Shake lasts for 20s of flight
                // Intensity calculation:
                // Original logic requested: const shakeAmount = 0.01 - 0.0025*(Math.abs(time - 4.5));
                // We want to match that "degree" (max ~0.01) and decay it.
                
                // Base intensity: 0.01 (half of previous 0.02)
                // Decay formula: (20 - flightTime) / 20 -> 1.0 to 0.0
                const decay = Math.max(0, (20 - flightTime) / 20);
                const shakeIntensity = 0.01 * decay; 
                
                camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                camera.position.y += (Math.random() - 0.5) * shakeIntensity;
                // camera.position.z += (Math.random() - 0.5) * shakeIntensity; // Removed Z shake to be closer to original feel
            }
        }

        function takeOff(t){
            // t is launchTime (starts at 0 when Launch button clicked)
            // 0s - 5s: Water Deluge / Pre-ignition
            // 5s+: Ignition and Lift-off
            
            const flightTime = t - 5.0; // Time elapsed since ignition

            // Lock ignition light until ignition time (t=5)
            if(!isLaunchPhase || flightTime < 0) {
                 light4.intensity = 0;
                 return;
            }

            // Ignition Light Logic
            light4.position.set(entire_starship.position.x,entire_starship.position.y-0.2,entire_starship.position.z)
            if(flightTime < 2.0){ // Ramp up light intensity over 2 seconds
                light4.intensity = flightTime * 100; 
            }

            // --- Lift-off Physics ---
            // Reduced acceleration again by 5x.
            // Previous: 0.006 * t^3
            // New: (0.006 / 5) * t^3 = 0.0012 * t^3
            entire_starship.position.y = 0.0012 * Math.pow(flightTime, 3); 
            
            // Horizontal Maneuver (Gravity Turn)
            // Start later due to slower ascent (wait until t=15s post-ignition)
            if (flightTime > 15) { 
                entire_starship.position.x = 0.002 * Math.pow(flightTime-15, 3); // Very slow turn

                if (flightTime < 30) {
                    entire_starship.rotation.z = - 0.002 * Math.pow(flightTime-15, 2);
                }
            }
        }

        // --- Transition Functions (Restored from Original Project) ---

        function hideSceneOne(){
            if(stationaries) stationaries.position.set(-1000, -1000, -1000);
            if(entire_starship) entire_starship.position.set(-1000, -1000, -1000);
            light2.position.set(2, 3, 4);
            light3.position.set(2, 6, 4);
            skyMeshOne.position.set(-1000, -1000, -1005);
            skyMeshTwo.position.set(0, 0, 5);
            // seperated_starship is handled in loadSceneTwo
            factory_door_l.position.set(-1000, -1000, -1000);
            factory_door_r.position.set(-1000, -1000, -1000);
            shockwaveMesh.visible = false; // Ensure shockwave is hidden
        }

        function loadSceneTwo(){
            seperated_starship.position.set(-15, 0.2, 0);
            light2.position.set(2, 3, 4);
            light3.position.set(2, 6, 4);

            // Hard-reset camera position to mimic original Scene 1 end state
            camera.position.set(0, 0.2, 3.61); // Approx 4.5 - log10(13)*0.8
            camera.rotation.set(0.18, 0, 60 * degree); // Reset X/Y, Set Z
            camera.setFocalLength(12); // Reset focal length from Scene 1 animation
        }

        function hideSceneTwo(){
            seperated_starship.rotation.set(18 * degree , 180 * degree, 85 * degree)
            seperated_starship.position.set(-1000, -1000, 0)
            camera.rotation.z = 0
        }
        
        // Restored animationSceneTwo from Original Project (replaces placeholder)
        function animationSceneTwo(time){
            // const phase_time = time - 12; // This logic is embedded in the math below
            // seperated_starship.position.set(0,0,0) // Placeholder removed
            seperated_starship.position.x += 0.07
            seperated_starship.position.z = 0.022 * Math.pow(time-3, 2) - 2
            seperated_starship.rotation.y -= 0.04 * degree
            
            camera.lookAt(seperated_starship.position)
        }

        function loadSceneThree(){
            seperated_head.position.set(0, 0, 0)
            seperated_booster.position.set(0, 0, 0)
            
            // Default Ship Camera Setup
            camera.position.set(0.1, 2, 0.25)
            camera.lookAt(0.1, 0, 0.25)

            // Show View Controls
            viewControls.style.display = 'block';
        }

        function hideSceneThree(){
            seperated_head.position.set(-1000, -1000,0)
            seperated_booster.rotation.set(0, 0, 0)
            
            // Hide View Controls
            viewControls.style.display = 'none';
            
            // Reset to default view for next scene
            activeView = 'ship';
            shipViewBtn.classList.add('active');
            boosterViewBtn.classList.remove('active');
        }

        function animationSceneThree(time){
            const phase_time = time - 14.5
            seperated_booster.rotation.z -= 0.01 * degree
            seperated_booster.position.x = -0.0002 * Math.pow(phase_time, 4)
            seperated_booster.position.y = -0.008 * Math.pow(phase_time, 3)
            seperated_booster.position.z = 0.001 * Math.pow(phase_time, 3)

            // Update Booster Camera (Attached to Booster, looking opposite to Ship)
            // Booster is moving away. We want the camera to be ON the booster, looking BACK at the ship (0,0,0)
            // The booster is rotating, so we must calculate the offset in the booster's local space 
            // and transform it to world space to get the correct "attached" position.
            
            // Revised position: Move down (-Y) and sideways (+X) relative to booster
            const boosterOffset = new THREE.Vector3(1.5, -2.0, 0); 
            boosterOffset.applyEuler(seperated_booster.rotation); // Rotate offset to match booster orientation
            boosterOffset.add(seperated_booster.position); // Add to booster world position
            
            boosterCamera.position.copy(boosterOffset);
            // Look at Ship (Static at 0,0,0 in this local frame context)
            // BUT use a fixed "Up" vector relative to the booster to prevent weird rolling? 
            // Or just look at ship. User said "fixed upward view watching the ship".
            boosterCamera.lookAt(seperated_head.position); 
            
            // Force camera rotation to be "upright" relative to the world or fixed axis?
            // "Fixed view looking up at ship" implies we don't want it to rotate WITH the booster spin?
            // User said "Fixed upward perspective watching the ship".
            // If we just set position relative to booster, but rotation is LookAt(0,0,0), it will track the ship.
            // "Sideways move" suggests an offset.
            // "No need to track" -> "Don't need tracking" might mean "Don't rotate camera to follow ship"?
            // "Fixed view looking up" -> static rotation?
            // "Attached to booster" -> Position moves with booster.
            // Combining: Position = Booster + Offset. Rotation = Fixed (looking up at 0,0,0).
            
            // Let's try: Position attached (as requested), LookAt ship (as requested "watching ship").
            // The "No need to track" likely means "Don't need complex tracking logic", just LookAt is fine.
            // The "Stuck inside" issue is solved by offset (1.5, -2.0, 0).
            
            boosterCamera.lookAt(seperated_head.position);
        }

        function loadSceneFour(){
            stationaries_2.position.set(0, 0, 0)
            seperated_booster.position.set(0.2, 10, 0)
            arm_1.position.set(-0.18, 0, 0.05)
            arm_2.position.set(0.18, 0, -0.05)
            camera.position.set(4.2, -0.2, 1.4)
            light4.intensity = 48;
            //camera.position.set(-1, -0.5, -0.1)
            //camera.lookAt(0, -0.5, 0.2)
            camera.setFocalLength(14);
        }
        
        function hideSceneFour(){
             // Not strictly needed unless we loop back, but good for completeness
            stationaries_2.position.set(-1000, -1000, 0)
            arm_1.position.set(-1000, -1000, 0)
            arm_1.rotation.y = 0
            arm_2.position.set(-1000, -1000, 0)
            arm_2.rotation.y = 0
            seperated_booster.position.set(-1000, -1000,0)
            seperated_booster.rotation.set(0, 0, 0)
            light4.position.set(-1000, -1000, 0)
        }

        function animationSceneFour(time){
            const phase_time = time - 25

            // Physics moves IMMEDIATELY (0s - 3s and onwards)
            
            if(phase_time > 6){
                arm_1.rotation.y = Math.min(45, (phase_time-6) / 3 * 45) * degree
                arm_2.rotation.y = -Math.min(46, (phase_time-6) / 3 * 46) * degree
            }
            
            // Physics Logic: Always runs from t=0
            seperated_booster.position.y = -1.44 + (Math.max(-1.44, 10 / ((phase_time-3) * 0.9 + 3) - 2.4) + 1.44) * 2
            seperated_booster.position.z = 0.5 + ((0.5 * (0.5 + Math.max(0.5, 10 / ((phase_time-3) * 1.3 + 6) - 0.125)))-0.5) * 2
            seperated_booster.rotation.x = Math.max(0, (8 - phase_time) * degree)

            camera.lookAt(seperated_booster.position.x, seperated_booster.position.y + 1, seperated_booster.position.z)
            const pos = seperated_booster.position
            
            // Fire/Light Logic: DELAYED by 3 seconds (starts at t=3)
            // Ends at t=12 (original logic). Total scene duration approx 12s.
            if(phase_time > 3 && phase_time < 12){
                exhaust2.emit(pos, new THREE.Vector3(0,-2,0), 0.6, 20);
                light4.position.set(seperated_booster.position.x,seperated_booster.position.y-0.2,seperated_booster.position.z)
                light4.intensity = 48 - 4 * phase_time
            } else {
                light4.intensity = 0;
            }
            
            // Show Success Modal 3 seconds after "engine cutoff" (t=12)
            // Cutoff at phase_time = 12. 
            // Show modal at phase_time = 12 + 3 = 15.
            if (phase_time > 15) {
                successModal.style.display = 'block';
            }
        }


        // Systems
        function createParticleSystem(color, size, opacity=0.8, map=null, blending=THREE.AdditiveBlending) {
            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(15000);
            geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
            const mat = new THREE.PointsMaterial({
                color, 
                size, 
                transparent:true, 
                opacity, 
                depthWrite:false,
                map: map,
                blending: blending
            });
            const points = new THREE.Points(geom, mat);
            points.frustumCulled = false; // Critical fix: Prevent particles from disappearing when moving out of initial bounds
            scene.add(points);
            let particles = [];
            let idx = 0;
            const posArray = pos;

            return {
                mesh: points, // Expose the mesh for removal
                emit(pos, vel, life=4, count=15) {
                    for(let i=0; i<count; i++){
                        particles.push({
                            p: pos.clone().add(new THREE.Vector3((Math.random()-0.5)*0.1,0,(Math.random()-0.5)*0.1)),
                            v: vel.clone().add(new THREE.Vector3((Math.random()-0.5)*0.4,0,(Math.random()-0.5)*0.6)),
                            life: life + Math.random()*0.5
                        });
                    }
                },
                update(dt) {
                    particles = particles.filter(p=> (p.life-=dt) > 0);
                    particles.forEach(p=> p.p.addScaledVector(p.v, dt));

                    let i=0;
                    particles.forEach(p=>{
                        posArray[i++] = p.p.x;
                        posArray[i++] = p.p.y;
                        posArray[i++] = p.p.z;
                    });
                    geom.setDrawRange(0, particles.length);
                    geom.attributes.position.needsUpdate = true;
                }
            };
        }

    </script>
</body>
</html>