<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>Starship 发射全流程 CG</title>
<style>
    body { margin:0; overflow:hidden; }
</style>
</head>
<body>
<script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

const scene   = new THREE.Scene();
const camera  = new THREE.PerspectiveCamera(80, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 0.8, 5);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// 灯光 & 天空
scene.add(new THREE.AmbientLight(0xffffff, 1));
const dirLight = new THREE.DirectionalLight(0xffffff, 4);
dirLight.position.set(5,10,7);
scene.add(dirLight);

const loader = new GLTFLoader();
let starship, booster, ship;           // 分离后会用到
let separated = false;

// 加载你的四个模型（路径按需改）
loader.load('stationaries.glb', g=>scene.add(g.scene));
loader.load('factory_door.glb',   g=>{ g.scene.position.set(-0.72,0,4); g.scene.scale.set(1.5,1.5,1.5); scene.add(g.scene); });
loader.load('factory_door2.glb',  g=>{ g.scene.position.set( 0.72,0,4); g.scene.scale.set(1.5,1.5,1.5); scene.add(g.scene); });
loader.load('entire_starship.glb', g=>{
    starship = g.scene;
    scene.add(starship);

    // 假设你的模型里 Booster 和 Ship 是两个子对象，名字叫 Booster 和 Ship（没有的话就改成实际名字）
    booster = starship.getObjectByName('Booster') || starship.children[0];
    ship    = starship.getObjectByName('Ship')    || starship.children[1];
});

// ==================== 粒子系统：白烟 + 橙色尾焰 ====================
const maxCount = 3000;
function createParticleSystem(color, size, opacity=0.8) {
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(maxCount*3);
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const mat = new THREE.PointsMaterial({color, size, transparent:true, opacity, depthWrite:false});
    const points = new THREE.Points(geom, mat);
    scene.add(points);
    let particles = [];
    let idx = 0;
    const posArray = pos;

    return {
        emit(pos, vel, life=1, count=15) {
            for(let i=0; i<count; i++){
                particles.push({
                    p: pos.clone().add(new THREE.Vector3((Math.random()-0.5)*0.3,0,(Math.random()-0.5)*0.3)),
                    v: vel.clone().add(new THREE.Vector3((Math.random()-0.5)*0.4,0,(Math.random()-0.5)*0.4)),
                    life: life + Math.random()*0.5
                });
            }
        },
        update(dt) {
            particles = particles.filter(p=> (p.life-=dt) > 0);
            particles.forEach(p=> p.p.addScaledVector(p.v, dt));

            let i=0;
            particles.forEach(p=>{
                posArray[i++] = p.p.x;
                posArray[i++] = p.p.y;
                posArray[i++] = p.p.z;
            });
            geom.setDrawRange(0, particles.length);
            geom.attributes.position.needsUpdate = true;
        }
    };
}

const vent    = createParticleSystem(0xffffff, 0.06, 0.6);   // 启动前白烟
const exhaust = createParticleSystem(0xffaa33, 0.15, 0.9);   // 点火尾焰

// ==================== 动画主循环 ====================
const clock = new THREE.Clock();
let t = 0;                    // 全局时间（秒）
const loopDuration = 60;      // 一个完整循环60秒

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    t += dt;

    const phase = t % loopDuration;   // 循环时间

    // ---------- 1. 工厂门打开（0–5秒） ----------
    const doorProgress = Math.min(phase / 5, 1);
    if(scene.children.find(o=>o.name.includes('factory_door'))){ // 安全判断
        const left  = scene.getObjectByName && scene.getObjectByName('left')  || scene.children.find(o=>o.position?.x<0);
        const right = scene.getObjectByName && scene.getObjectByName('right') || scene.children.find(o=>o.position?.x>0);
        if(left)  left.rotation.y  =  doorProgress * Math.PI;
        if(right) right.rotation.y = -doorProgress * Math.PI;
    }

    // ---------- 2. 相机动画（四个阶段无缝切换） ----------
    if(phase < 8){
        // 0–8秒：从工厂慢慢推近 + 镜头微微变焦
        const p = phase / 8;
        camera.position.z = THREE.MathUtils.lerp(5, 1.8, p);
        camera.position.y = THREE.MathUtils.lerp(0.8, 2.5, p);
        camera.fov = THREE.MathUtils.lerp(80, 50, p);
        camera.updateProjectionMatrix();
        camera.lookAt(0,1,0);
    }
    else if(phase < 20){
        // 8–20秒：跟随火箭上升（侧后方追拍）
        const p = (phase-8)/12;
        camera.position.set(
            Math.sin(p*2)*4,
            3 + p*15,
            3 + p*8
        );
        camera.lookAt(0, 3+p*15, 0);
    }
    else if(phase >= 20 && phase < 35){
        // 20–35秒：分离阶段，拉远看全貌
        const p = (phase-20)/15;
        camera.position.set(8, 15+p*20, 12);
        camera.lookAt(0, 15+p*20, 0);
    }
    else if(phase >= 35){
        // 35–60秒：助推器返回着陆
        camera.position.set(6, 8, 10);
        camera.lookAt(0,0,0);
    }

    // ---------- 3. 火箭运动 ----------
    let rocketY = 0;
    if(phase > 5){
        rocketY = (phase-5) * 0.8;                     // 线性上升，可改成 easeOutQuad 更真实
    }

    if(!separated && starship){
        starship.position.y = rocketY;
    }

    // ---------- 4. 级间分离（第25秒） ----------
    if(phase > 25 && !separated && booster && ship){
        separated = true;

        // 把 booster 和 ship 从 starship 里“抠”出来，独立控制
        const bp = new THREE.Object3D(); bp.add(booster); scene.add(bp);
        sp = new THREE.Object3D(); sp.add(ship);     scene.add(sp);

        bp.position.copy(starship.position);
        sp.position.copy(starship.position);

        scene.remove(starship);
        starship = null;
    }

    // 分离后各自运动
    if(separated){
        bp.position.y -= dt * 1.2;          // 助推器下落
        sp.position.y += dt * 2;            // 飞船继续上升

        // 助推器接近地面时点火着陆（最后10秒）
        if(bp.position.y < 8){
            exhaust.emit(bp.position.clone().add(new THREE.Vector3(0,-2,0)),
                        new THREE.Vector3(0,-3,0), 0.6, 30);
        }
    }

    // ---------- 5. 粒子效果 ----------
    if(starship || bp){
        const tailPos = (starship ? starship : bp).position.clone().add(new THREE.Vector3(0,-1.8,0));

        // 0–5秒：冒白烟
        if(phase < 5){
            if(Math.random()<0.4) vent.emit(tailPos, new THREE.Vector3(0,0.3,0), 3, 8);
        }
        // 5秒后：剧烈尾焰 + 抖动
        else if(phase < 25 || (separated && bp.position.y > 8)){
            exhaust.emit(tailPos, new THREE.Vector3(0,-6,0), 0.8, 40);
        }
    }

    vent.update(dt);
    exhaust.update(dt);

    // ---------- 6. 镜头抖动（点火后3秒最猛） ----------
    if(phase > 5 && phase < 10){
        const shake = Math.sin((phase-5)*30) * (10-phase)/5 * 0.06;
        camera.position.x += shake * (Math.random()-0.5);
        camera.position.y += shake * (Math.random()-0.5);
        camera.rotation.z  += shake * 0.1;
    }

    renderer.render(scene, camera);
}
animate();

window.onresize = ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
};
</script>
</body>
</html>